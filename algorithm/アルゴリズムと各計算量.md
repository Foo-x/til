# アルゴリズムと各計算量

## 探索

### 全探索

- 概要: あり得るパターンをすべて探索する
- 計算量: 全パターン数

ループ（または多重ループ）を回すだけの最も単純な探索。  
最初に検討し、実行時間に問題なければこれでOK。  
このアルゴリズムに限らないが、値の組み合わせによって計算する必要がないパターンは枝刈りするなどして計算量を減らせる。


### ビット全探索

- 概要: N個の値から複数選ぶパターンをすべて探索する
- 計算量: 2^N

i番目の値を選ぶ/選ばないでそれぞれ2通り、N個で2^N通りを探索。  
2^N回ループを回し、各ステップでループカウンタと`1 << i`との論理積がi番目を選んだかどうかに対応する。（`<<`はビット左シフト）  
例えばループカウンタが4の場合は2進表記で`100`になるため、2番目を選び、0番目と1番目を選ばないケースに対応する。

```cpp
for (int bit = 0; bit < (1 << N); ++bit) {
  for (int i = 0; i < N; ++i) {
    if (bit & (1 << i)) {
        // i番目を選ぶ場合の処理
    }
  }
}
```

参考
- [bit 全探索 - けんちょんの競プロ精進記録](https://drken1215.hatenablog.com/entry/2019/12/14/171657)


### 二分探索

- 概要: ソート済みの配列から探したい値の位置を効率的に探す
- 計算量: logN

1. 配列をソートする
2. 配列の中央値と探したい値を比較する
3. 探したい値が中央値より小さい場合は中央値より左側、大きい場合は中央値より右側を再帰的に探索する

ある条件を満たす最大（最小）の値を効率よく見つけられる。


### 深さ優先探索

> Depth First Search (DFS)

- 概要: グラフ構造をLIFOで探索する
- 計算量: N

1. 最初に探索するノードを決めて探索予定の集合に入れる
2. 最後に集合に入れたノードを取り出す
3. そのノードに接続しているノードを集合に入れる
4. 集合が空でなければ2.に戻る

探索予定の集合はスタック構造で実現可能。


### 幅優先探索

> Breadth First Search (BFS)

- 概要: グラフ構造をFIFOで探索する
- 計算量: N

1. 最初に探索するノードを決めて探索予定の集合に入れる
2. 最初に集合に入れたノードを取り出す
3. そのノードに接続しているノードを集合に入れる
4. 集合が空でなければ2.に戻る

探索予定の集合はキュー構造で実現可能。


## ソート

- 安定ソート
    - 同じ値に対して元の順序を保つソート
    - 安定ソートでなくても、元の順序をソート条件に含めることで安定ソートにできる
        - その場合は計算量と記憶領域が増える
- 内部ソート
    - ソート対象のデータ領域のみを使用するソート
- 外部ソート
    - ソート対象のデータ領域以外に一時的な領域を必要とするソート

参考
- [ソート - Wikipedia](https://ja.wikipedia.org/wiki/%E3%82%BD%E3%83%BC%E3%83%88)
- [ソートを極める！ 〜 なぜソートを学ぶのか 〜 - Qiita](https://qiita.com/drken/items/44c60118ab3703f7727f)


### 挿入ソート

| 平均計算量 | 最悪計算量 | 必要な外部領域 | 安定性 |
| --- | --- | --- | --- |
| N^2 | N^2 | 0 | 〇 |

1番目と2番目を比較し、逆であれば入れ替える。  
3番目以降について、適切な位置に挿入することを繰り返す。  
ほぼ整列済みの配列に対してはO(N)に近くなることから、他のソートと組み合わせて使われることが多い。  

- C++: イントロソートをある程度行って、ほぼ整列済みになったら挿入ソート
- Python, Java: ティムソート（マージソートと挿入ソートの組み合わせ）


### マージソート

| 平均計算量 | 最悪計算量 | 必要な外部領域 | 安定性 |
| --- | --- | --- | --- |
| NlogN | NlogN | N | 〇 |

配列を半分に分けて、それぞれをソートしてからマージすることを再帰的に行う。  
マージはそれぞれの列の先頭を比較して小さいほうを取り出すことを再帰的に行う。

例
```
3 7 1 8 4 6 5 2

3 7 1 8 | 4 6 5 2

3 7 | 1 8 | 4 6 | 5 2

3 | 7 | 1 | 8 | 4 | 6 | 5 | 2

3 7 | 1 8 | 4 6 | 2 5

1 3 7 8 | 2 4 5 6

1 2 3 4 5 6 7 8
```

たとえば5ステップ目の`3 7 | 1 8`のマージは以下のような処理になる。

| マージ対象 | マージ済み |
| --- | --- |
| 3 7 \| 1 8 | - |
| 3 7 \| 8 | 1 |
| 7 \| 8 | 1 3 |
| 8 | 1 3 7 |
| - | 1 3 7 8 |

最悪計算量が小さく、並列化できる上に安定ソートなので良く使われる。


### ティムソート

| 平均計算量 | 最悪計算量 | 必要な外部領域 | 安定性 |
| --- | --- | --- | --- |
| NlogN | NlogN | N | 〇 |

マージソートの改良版。  
配列を小さいサイズに分割し、それぞれで挿入ソートを行ってからマージソートを行う。  
小さいサイズにおいてはマージソートより挿入ソートのほうが速いので、全体として通常のマージソートより速くなる。


### ヒープソート

| 平均計算量 | 最悪計算量 | 必要な外部領域 | 安定性 |
| --- | --- | --- | --- |
| NlogN | NlogN | 0 | × |

配列から二分ヒープに要素を追加し、その数だけ根から取り出す。  
ヒープソート自体はあまり使われないが、ソート状態を保ったまま要素を高速に追加/削除できるヒープはよく使われる。  
並列化はできない。


### クイックソート

| 平均計算量 | 最悪計算量 | 必要な外部領域 | 安定性 |
| --- | --- | --- | --- |
| NlogN | N^2 | 0 | × |

1. 配列から適当な要素（ピボット）を選び右端に移動させる
2. 走査し、選んだ要素より小さい値を左端に詰めていく
3. 走査が完了したら選んだ要素より小さい値の右端に選んだ要素を移動する
4. 選んだ要素の左側と右側で再帰的に繰り返す

例

| 配列 | 操作 |
| --- | --- |
| 2 3 5 1 4 | 適当に3を選んだとする |
| 2 5 1 4 3 | 3を右端に移動 |
| 2 1 5 4 3 | 3より小さい値を左端に詰める |
| 2 1 3 5 4 | 3より小さい値の右端に3を移動 |
| ... | 以下 `2 1` と `5 4` で同様の処理 |
| 1 2 3 4 5 | |

平均計算量は定数倍で他のソートより高速だが、ピボットの選び方によっては最悪O(N^2)になる。  
マージソートと同様に分割統治法なので並列化できる。


### イントロソート

| 平均計算量 | 最悪計算量 | 必要な外部領域 | 安定性 |
| --- | --- | --- | --- |
| NlogN | NlogN | logN | × |

クイックソートの改良版。  
最初はクイックソートを行い、再帰の深さが一定数（C++だと要素数の対数の2倍）を超えたらヒープソートに切り替える。


### バケットソート

| 平均計算量 | 最悪計算量 | 必要な外部領域 | 安定性 |
| --- | --- | --- | --- |
| N + K | N^2 | NK | 〇 |

（Kは配列内の要素の種類）

配列内の要素に対応するソート済みのバケットを用意し、各要素をバケットに移して結合する。  

例: 値の範囲が10から20とわかっている場合
```
配列: 11 15 13 19 17 18
バケット: 10 11 12 13 14 15 16 17 18 19 20

配列の各要素をバケットに移し、結合することでソート済みの配列が得られる。
11 13 15 17 18 19
```

取りうる値の範囲が小さければ高速だが、配列の要素数より大きいとO(NlogN)の他のソートのほうが速い。


### 基数ソート

| 平均計算量 | 最悪計算量 | 必要な外部領域 | 安定性 |
| --- | --- | --- | --- |
| NK | NK | NK | 〇 |

（Kは最大桁数）

N進法で表現可能な値を要素とする配列について、1の位から順に位を大きくしながらバケットソートを行う。

例

| 配列 | 操作 |
| --- | --- |
| 170 45 75 90 2 24 802 66 | 初期状態 |
| 170 90 2 802 24 45 75 66 | 1の位でソート |
| 2 802 24 45 66 170 75 90 | 10の位でソート |
| 2 24 45 66 75 90 170 802 | 100の位でソート |


## 整数

### ユークリッドの互除法

- 概要: 2つの数値の最大公約数を求める
- 計算量: logN
    - Nは小さいほうの数値

2つの数値のうち大きいほうをA、小さいほうをBとして、AをBで割る。  
あまりをCとして、BをCで割る。  
再帰的に繰り返し、あまりが0になったときの除数がAとBの最大公約数。


### エラトステネスの篩

- 概要: ある値以下の素数をすべて求める
- 計算量: NloglogN

1. 2からNまでの整数をリストLに入れる
2. 素数リストPを用意する
    - このリストが最終的に求めたい素数のリストになる
3. Lの先頭から順に値xを取り出し、xが√Nを超えるまでそれぞれ以下の処理を行う
    1. xをPに入れる
    2. xの倍数をLから削除する
4. Lに残っている値をPに入れる


## 動的計画法

ある問題を小さな問題に分解し、それらの解を使って帰納的に解を求める方法。  
トップダウン方式とボトムアップ方式がある。

例: フィボナッチ数列Fの5番目を動的計画法で解く
- 定義通り計算（動的計画法を使わない）
    - `f(5) = f(4) + f(3)`
    - `f(5) = (f(3) + f(2)) + (f(2) + f(1))`
    - `f(5) = ((f(2) + f(1)) + (f(1) + f(0)) + ((f(1) + f(0)) + f(1))`
    - `f(5) = (((f(1) + f(0)) + f(1)) + (f(1) + f(0))) + ((f(1) + f(0)) + f(1))`
    - 計算量は2^N
- トップダウン方式
    - フィボナッチ数列の定義通り再帰的に計算していくが、1度計算した値は保持しておいて2回目以降は計算しない
    - 計算量はN
    - この方式をメモ化再帰ともいう
- ボトムアップ方式
    - `f(1)`から順に求める
    - 計算量はN


## グラフ

### ダイクストラ法

- 概要: 負数を含まない重み付きグラフについてあるノードから各ノードへの最短経路を求める
- 計算量: ElogV

（Eは辺の数、Vはノードの数）

1. ノードと始点からの距離の組を保持する優先度付きキューを用意する
    - 優先度は距離の短い順
2. ノードと始点からの距離を記録するリストを用意する
    - 最終的にこれが求めたい結果になる
3. 始点と距離0の組をキューに追加する
4. キューが空になるまで以下をループする
    1. キューの先頭をpopする
    2. popしたノードAに対する距離Xをリストに記録する
    3. Aに接続するノードのリストについて、まだ始点からの距離が記録されていない場合は、そのノードBとX+AB間の距離の組をキューに追加する

貪欲法の一種。

Eの範囲は`V`から`V(V-1)/2`なので、計算量はElogEとも書ける。(O(ElogE) = O(ElogV^2) = O(2ElogV) = O(ElogV))

重みなしグラフの場合は幅優先探索のほうが速い。(O(E))

参考: [ダイクストラ法（最短経路問題）](http://www.deqnotes.net/acmicpc/dijkstra/)


### ベルマンフォード法

- 概要: 負数を含む重み付きグラフについてあるノードから各ノードへの最短経路を求める
- 計算量: EV

（Eは辺の数、Vはノードの数）

1. 始点に対する距離を0、始点以外の全ノードに対する距離を無限大で初期化
2. すべての辺について、各ノードに対する距離を最短距離で更新
3. 2.をV-1回繰り返す

ループ1回目で始点から行けるノード、2回目でそこから行けるノード、と最短距離が更新されていく。  
負の閉路がある場合は最短距離を複数回更新できるノードが見つかるので、負の閉路を検出できる。

動的計画法の一種。

参考: [ベルマンフォード法とダイクストラ法の概念を完全に理解する - Qiita](https://qiita.com/ko-ya346/items/359a3e03c5e20b04c573)

### SPFA (Shortest Path Faster Algorithm)

- 概要: 改良版ベルマンフォード法
- 計算量: EV

（Eは辺の数、Vはノードの数）

基本はベルマンフォード法と同じ。  
各ループですべての辺について計算する代わりに、キューを使用して最短距離を更新できるノードのみ計算を行う。  
計算量としてはベルマンフォード法と同じだが、負数が少ない場合は計算量が減り、平均的にはO(E)になるらしく、場合によってはダイクストラ法より速いこともある。


### ワーシャルフロイド法

- 概要: 負数を含む重み付きグラフの全ノード間の最短経路を求める
- 計算量: V^3

（Vはノード数）

ノードij間の最短経路は、

- ij間の辺
- ij以外のすべてのノードkに対して、ikの最短経路+kjの最短経路

のV通りのどれかになる。

```cpp
for (int k = 0; k < V; k++) {
    for (int i = 0; i < V; i++) {
        for (int j = 0; j < V; j++) {
            result[i][j] = min(result[i][j], resulj[i][k] + resutj[k][j]);
        }
    }
}
```


### クラスカル法

- 概要: グラフの最小全域木を求める
- 計算量: ElogV

（Eは辺の数、Vはノードの数）

最小全域木とはグラフのすべてのノードを含むもののうち、辺の重みの和が最小のもの。

1. すべての辺を含むリストEを用意する
2. Eを辺の重みでソートする
3. Union-Find木Uを用意する
4. 使用する辺の集合Fを用意する
    - これが最小全域木で使用する辺の集合になる
5. Eの各辺eについて、両端のノードがUで同じ集合に含まれていない場合は同じ集合にしてeをFに入れる

参考: [クラスカル法 - Wikipedia](https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%A9%E3%82%B9%E3%82%AB%E3%83%AB%E6%B3%95)

### プリム法

- 概要: グラフの最小全域木を求める
- 計算量: ElogV

（Eは辺の数、Vはノードの数）

1. ノードを入れる空集合Vと辺を入れる空集合Eを用意する
    - 最終的にEが最小全域木で使用する辺の集合になる
2. グラフから任意の頂点をVに入れる
3. Vがすべてのノードを含むまで以下をループする
    1. Vに含まれるノードuから含まれないノードvを結び、重みが最小の辺eをグラフから選び、vをVに入れてeをEに入れる

参考: [プリム法 - Wikipedia](https://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AA%E3%83%A0%E6%B3%95)
