# ビットのTips

以下、論理演算を以下の演算子で表す。

| 演算 | 演算子 |
| --- | --- |
| AND | & |
| OR | \| |
| XOR | ^ |
| NOT | ~ |
| 左シフト | << |
| 右シフト | >> |


## 偶奇判定

Nは`N & 1`の値が1の場合に奇数、0の場合に偶数となる。


## 2のべき乗の乗算

`N << 1`で`N * 2`、`N << 2`で`N * 4`、以降も同様に2のべき乗の乗算が計算できる。


## 2のべき乗の除算

`N >> 1`で`N / 2`、`N >> 2`で`N / 4`、以降も同様に2のべき乗の除算が計算できる。（小数点以下切り捨て）  


## 偶数のXOR

偶数Nについて、`N^(N+1)`は常に1になる。  
NとN+1で異なるビットは最下位ビットのみになるため。


## 0からNまでのXOR

- Nが2の偶数倍
    - N
- Nが2の奇数倍
    - N+1
- Nが奇数かつN+1が2の偶数倍
    - 0
- Nが奇数かつN+1が2の奇数倍
    - 1

```
# N=4: Nが2の偶数倍

  0^1^2^3^4
= (0^1)^(2^3)^4
= 1^1^4
= 0^4
= 4


# N=6: Nが2の奇数倍

  0^1^2^3^4^5^6
= (0^1)^(2^3)^(4^5)^6
= 1^1^1^6
= 0^1^6
= 1^6
= 7


# N=7: Nが奇数かつN+1が2の偶数倍

  0^1^2^3^4^5^6^7
= (0^1)^(2^3)^(4^5)^(6^7)
= 1^1^1^1
= 0^1^1
= 1^1
= 0


# N=5: Nが奇数かつN+1が2の奇数倍

  0^1^2^3^4^5
= (0^1)^(2^3)^(4^5)
= 1^1^1
= 0^1
= 1
```


## 区間のXOR

区間AからBまでのXORは、0からA-1までのXORと、0からBまでのXORとのXORと同じ。

- 0からA-1までのXOR: `0^1^...^(A-1)`
- 0からBまでのXOR: `0^1^...^(A-1)^A^...^B`
- 上2つのXOR: `A^...^B`
    - 任意のNについて、`N^N=0`のため

「0からNまでのXOR」の項と上の性質により、区間のXORはO(1)で計算できる。


## 複数フラグ管理

ビットの各桁の0/1を用いることで複数のフラグを1つの変数で管理できる。  
たとえば3つのフラグを管理したい場合、3桁のビットで実現できる。

- i番目のフラグの値
    - `bit & (1 << i)`
- i番目のフラグを立てる
    - `bit = bit | (1 << i)`
- i番目のフラグを下ろす
    - `bit = bit & ~(1 << i)`

なお、特定のフラグを立てる/下ろすときに使用されるビットのことをマスクビットという。

例
```cpp
const unsigned int MASK_DOKU = (1 << 0);
const unsigned int MASK_MAHI = (1 << 1);
const unsigned int MASK_DOKU_MAHI = MASK_DOKU | MASK_MAHI;
```
